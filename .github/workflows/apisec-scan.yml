#include <iostream>
using namespace std;

// Forward declaration for operator<<
class Point;
std::ostream& operator<<(std::ostream& out, const Point& c);

class Point {
public:
    int x, y;

    Point(int x = 0, int y = 0) : x(x), y(y) {}

    Point& operator=(const Point& rhs) {
        if (this != &rhs) {
            x = rhs.x;
            y = rhs.y;
        }
        return *this;
    }

    // Allow access in derived class (or use friend/getters)
    virtual ~Point() = default;
};

// Output operator
std::ostream& operator<<(std::ostream& out, const Point& c) {
    out << "x:" << c.x << " y:" << c.y << "\n";
    return out;
}

class Complex : public Point {
private:
    // Avoid references to base members â€” use direct access or getters
    // References to x/y cannot be reseated and are risky here
    int real_part() const { return x; }
    int imag_part() const { return y; }

public:
    Complex(int r, int i) : Point(r, i) {
        cout << "Forming Complex: " << *this;
    }

    // Optional: custom output
    friend std::ostream& operator<<(std::ostream& out, const Complex& c) {
        out << "Complex(" << c.real_part() << " + " << c.imag_part() << "i)";
        return out;
    }
};

int main() {
    Complex c1(15, 15);
    Complex c2(100, 100);

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;

    return 0;
}
